1.lambda表达式其实就是为了简化接口的实现诞生的
对于原本的接口形参,我们的实参方式是可以通过三个方式:1.直接写一个类去继承接口(再重写相应的方法)
                                           2.使用匿名内部类的方法(方法编写出来)
                                           3.lambda表达式(但是只能实现一个方法-函数式接口)
2.函数式接口就是有且仅有一个必须实现的方法的接口
interface Test1{
    void test();//(只有没带大括号的非defualt非static方法才是必须实现的)
}
但是如果没有方法但是从父类继承了有且仅有一个的必须实现的方法
toString()//这个方法是从父类Obj上面实现的

3.lambda表达式的基础语法(无需关注方法名称)(就是一个动作,当做接口来用)
(参数列表) -> {
    方法体
};

4.上述语法还可以继续精简
参数部分:返回值类型在接口上面就确定了!!!同样的,参数的类型也定义了!因此可以直接去掉参数的类型!!
        如果参数有且仅有一个小括号可以省略
        如果仅有一段代码,那么大括号也可以省略(该语句如果是retuen,就别写return了)

5.lambda表达式的逻辑不能过于复杂,如果过于复杂,那么就会让代码的可读性更差
如果真的过于复杂或者提前写好了,那么就可以直接在lambda表达式中直接引用这个方法
其名为  方法的引用(对lambda复用和复杂的代码的简化)
也有限制(无论是哪里的方法,都必须保证参数列表和参数返回值是一致的)但是只要满足了该条件,无视名字直接调用不属于自己的方法
归根结底,两种方式都是让函数得以直接用调用的方法来做其中的"动作"

6.方法的引用(不要添加小阔号)他不是方法的调用(方法名他直接变成了函数的方法名)
静态方法:  类::静态方法
非静态方法:  对象::非静态方法
special: 如果lambda表达式中仅仅用形参(对象)去调用另外一个方法方法,那么就可以直接用 (类::非静态方法) 的形式
构造方法:  类::new(这里就是看究竟接口的参数类型了)(但是返回值都是固定的!!!)
如果一个函数式接口中定义的方法仅仅是为了得到一个对象,那么就可以用构造方法的引用,只要参数类型和返回值类型相同,就可以直接调用

7.还有一些需要注意的地方
