1.什么是线程
#并发看起来像是同时执行,其实仅仅是不断地再二者之间来回跳动
#不同于多进程,多线程中各个线程之间是共享一套变量的
#多线程比多进程更加的轻量级
#实现:需要一个继承了Runnable类的对象(本身也行),然后重写run()方法.在用该对象构造Thread类的对象,在调用该对象的start()方法就行了
一个方法run()这不正是lambda表达式么


2.线程状态
#可运行线程
只要是start之后的线程就是处于这种状态(不改变,无论是不是在运行都是)
可用静态方法yield()交出权限
#阻塞状态
超时,锁,等待.都是阻塞状态的表现
#终止状态
正常结束,未捕获异常,stop()杀死


3.线程属性
#中断线程(只是为了引起注意,具体怎么做看自己)
废弃了的stop()方法是唯一可以强制杀死线程的
因此目前可以用interrupt()方法就可以设置"中断状态",然后再静态Thread.currentThread()获取当前线程,并用isInterrup()方法返回一个boolean
就可以凭此来进行条件限制线程从而侧面的达到终止线程的目的
但是同样具有一个问题:调用了interrupt()方法的线程在调用终止代码会被异常中断,因为对这类线程的处理有些情况下会非常重要,因此必须捕获保证程序进行
正是因为如此,只要调用了sleep()之类的方法,就需要捕获异常,那么也就不需要要判断线程的终止请求了(如果有直接就会有异常被捕获!!这样同样得到了通知)
interrupted()方法是清楚终止状态.注意区分!!
有些代码在底层就抑制了该异常,这毫无意义,异常就是要让大家知道状态,抛出去就行了
#守护线程
类似于计时器线程,是为其他线程服务的
如果仅剩守护线程,那么程序也就停止了
#线程名
可以用setName()方法设置
#未捕获异常的处理器
为了防止未捕获线程导致线程被杀死
可以安装默认处理器(Thread的静态方法为所有线程安装)
没安装会有自带一个处理器(先看父线程,再看默认,如果是实例则不做,最后会描绘轨迹)
#线程优先级
虽然可以手动设置,但是更多情况下是依赖系统本身

4.同步(大多数实际情况中,多个线程会对同一个数据进行存取,因此容易造成覆盖,因此对象会被破坏,这叫做"竞态条件")
#
