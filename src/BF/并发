1.什么是线程
#并发看起来像是同时执行,其实仅仅是不断地再二者之间来回跳动
#不同于多进程,多线程中各个线程之间是共享一套变量的
#多线程比多进程更加的轻量级
#实现:需要一个继承了Runnable类的对象(本身也行),然后重写run()方法.在用该对象构造Thread类的对象,在调用该对象的start()方法就行了
一个方法run()这不正是lambda表达式么


2.线程状态
#可运行线程
只要是start之后的线程就是处于这种状态(不改变,无论是不是在运行都是)
可用静态方法yield()交出权限
#阻塞状态
超时,锁,等待.都是阻塞状态的表现
#终止状态
正常结束,未捕获异常,stop()杀死


3.线程属性
#中断线程(只是为了引起注意,具体怎么做看自己)
废弃了的stop()方法是唯一可以强制杀死线程的
因此目前可以用interrupt()方法就可以设置"中断状态",然后再静态Thread.currentThread()获取当前线程,并用isInterrup()方法返回一个boolean
就可以凭此来进行条件限制线程从而侧面的达到终止线程的目的
但是同样具有一个问题:调用了interrupt()方法的线程在调用终止代码会被异常中断,因为对这类线程的处理有些情况下会非常重要,因此必须捕获保证程序进行
正是因为如此,只要调用了sleep()之类的方法,就需要捕获异常,那么也就不需要要判断线程的终止请求了(如果有直接就会有异常被捕获!!这样同样得到了通知)
interrupted()方法是清楚终止状态.注意区分!!
有些代码在底层就抑制了该异常,这毫无意义,异常就是要让大家知道状态,抛出去就行了
#守护线程
类似于计时器线程,是为其他线程服务的
如果仅剩守护线程,那么程序也就停止了
#线程名
可以用setName()方法设置
#未捕获异常的处理器
为了防止未捕获线程导致线程被杀死
可以安装默认处理器(Thread的静态方法为所有线程安装)
没安装会有自带一个处理器(先看父线程,再看默认,如果是实例则不做,最后会描绘轨迹)
#线程优先级
虽然可以手动设置,但是更多情况下是依赖系统本身

4.同步(大多数实际情况中,多个线程会对同一个数据进行存取,因此容易造成覆盖,因此对象会被破坏,这叫做"竞态条件")
#产生原理:因为一个现成的更新抹消了另外一个线程的更新
#锁对象:synchronized关键字或者ReentrantLock类(同时也代表你希望多个线程使用一个变量),当然也可以嵌套哦
不同的对象时"重入锁"可以被分别获得(有一个计数器)
#条件对象:用来控制那些获得了锁却不做有用工作的线程(一定要让其他线程来调用相应方法不然就会造成死锁)
#synchronized关键字:这是一个对象内部锁,因为你不需要那么麻烦
静态方法的锁会让该类的该方法被锁死
三种写法:锁对象 共享一个对象(被锁了)
        锁实例方法 只会锁住该对象的有锁的实例方法
        锁静态方法 直接类锁,所有对象的有锁的静态方法
#同步块:使用synchronized(lock)可以创建一个同步块(原子性)
#监视器概念:由于锁和条件始终不是面向对象的,因此监视器诞生了,它有如下特性
           监视器是只包含私有字段的类
           监视器类的每一个对象都有一个锁
           所有方法都由这个锁锁定.
           所可以有多个相关联的条件
虽然java对象都有内部锁和内部条件,但是具有以下缺点:字段不要求是private
                                          方法不要求是synchronized
                                          内部锁对客户是可以用的
#volatile字段:即使为了一两个语句而使用同步仿佛有些划不来,但是不用出问题几率很大
              多核处理器1个内存位置可能有不同的值
              编译器改变指令执行的顺序以使吞吐量最大化,因此内存可能被另外一个线程修改
虽然保证了可见性却没有保证原子性(要被中断)
#final变量:通过延后读取时间保证了其他线程看到的是更新后的值,但是仍然线程不安全
#原子性:java中有许多方法可以以原子性来执行一系列指令
       但是如果有大量线程要访问相同的原子值,那么性能就会严重下降,就要用到其他的类(以一种累计的方式)
#死锁:两个线程互相可以解除对方的阻塞状态但是二者同时阻塞了
#线程的局部变量:如果总是使用同步,那么开销可能会很大,因此可以为每一个线程实例化一个独有的变量
public static final ThreadLocal<SimpleDateFormat> dateFormat = ThreadLocal.withInitial(()->newSimpleDateFormat("yyyy-MM-dd"));
可以用String date = dateFormat.get().format(new Date);查看格式化方法
随机数也是同样的道理(多个线程使用同一个随机器效率会非常低)(在构造线程就可以给予不同的随机数器)
#为什么废弃stop和suspend方法:
stop会导致对象处于一种不一致的状态
suspend会导致对象很容易死锁(不是两个对象互相帮助的)

5.线程安全的集合
#可以使用一个线程插入一个线程取出元素这一优雅的操作
同样的为了避免抛出异常可以更换方法(异常的抛出会转换为一个错误提示(自己定义的异常???))

6.任务和线程池(扔进去任务,线程池内的线程来完成)
future用储存相应信息的(通过提交返回的),会返回一个结果
callable表示任务
Executors是线程池
构造一个新的线程开销有些大.如果存在大量的生命周期较短的线程,那么就可以放入线程池
#Callable<T>是一个用来发出请求的接口
Future<V>是一个保存异步计算结果的接口(如果中断需要找到线程位置)get()是通过阻塞的原理实现的
#执行器:一系列的静态方法来构造线程
单线程池用来分析情况十分好用(对比)
#如何链接线程池:调用执行器的静态方法创建
             调用submit提交线程和通知对象
             保存好Future对象
             如果不在提交任务就调用shutdown
#控制任务组:通过提交一个任务的集合(线程池对象的方法),返回一个Future集合(但是会存在堵塞现象,因此可能会在所有完成之后才会终止堵塞)
因此需要用 线程池完成管理 :构造需要一个管理器对象,这里不能直接用集合添加了,得用集合遍历添加(用的是完成管理器的submit方法),最后用get()之前
多调用一个take()方法
invokeAll()可以直接把一个集合提交上去并且返回一个future集合
